#include <SoftwareSerial.h>
#include <TinyGPS++.h>

const int RXPin = 4, TXPin = 5;  
const uint32_t GPSBaud = 4800;

SoftwareSerial gpsSerial(RXPin, TXPin); // RX, TX
TinyGPSPlus gps;

volatile bool ppsTriggered = false; //Une variable booléenne ppsTriggered est utilisée pour indiquer si une interruption PPS s'est produite. 
unsigned long lastPpsTime = 0; //lastPpsTime stocke le temps de la dernière interruption PPS.

float lastSpeed = 0.0;  // dernière vitesse 
float interval = 1000; // ms 

void setup() {
  Serial.begin(9600);
  gpsSerial.begin(GPSBaud);
  pinMode(3, INPUT); // PPS pin (2 ou 3 sur Arduino pour interruption) // Si simulateur -> c'est là ou je mets le pin relié au bouton
  
  attachInterrupt(digitalPinToInterrupt(3), ppsISR, RISING); // fonction d'interruption qui va nous permettre de dire que l'interruption a eu lieu, 
                                                             // donc que le PPS Pin est actif et qu'on peut lire les données 
  Serial.println(F("Arduino - GPS module"));                                                       
}

void loop() {

  if (ppsTriggered && (millis() - lastPpsTime >= interval)) {    //si une interruption PPS a été déclenchée (voir fct d'interruption) et que le temps écoulé depuis la dernière interruption est supérieur ou égal à l'intervalle d'impression, 
                                                                      // le traitement des données GPS est effectué
                                                             
    ppsTriggered = false; // on le remet en faux pour la prochaine fois 
    lastPpsTime=millis(); // Je prends le moment où on rendre dans la boucle et le conserve pour après 
      // update GPS data
    if (gpsSerial.available() > 0) { // plutôt if ou while -> j'utilise car comme beaucoup de données GPS arrivent en peu de temps, pas forcément besoin de toutes les lires quand elles arrivent en continue
      gps.encode(gpsSerial.read());
    }

    if (gps.location.isValid()) {   
        Serial.print(F("- latitude: "));
        Serial.println(gps.location.lat());

        Serial.print(F("- longitude: "));  //print(F()) signifie que le string n'utilise pas de RAM. Si vous utilisez F(), vous pouvez déplacer les string constant vers la mémoire programme au lieu de la RAM. Cela prendra de l'espace et diminuera la quantité d'autre code que vous pouvez écrire. Mais cela libérera de la RAM dynamique.
        Serial.println(gps.location.lng());

        Serial.print(F("- altitude: "));
        if (gps.altitude.isValid())
          Serial.println(gps.altitude.meters());
        else
          Serial.println(F("INVALID"));
      } else {
        Serial.println(F("- location: INVALID"));
      }
      Serial.print(F("- GPS date&time: "));
        if (gps.date.isValid() && gps.time.isValid()) {
           Serial.print(gps.date.year());
           Serial.print(F("-"));
           Serial.print(gps.date.month());
           Serial.print(F("-"));
           Serial.print(gps.date.day());
           Serial.print(F(" "));
           Serial.print(gps.time.hour());
           Serial.print(F(":"));
          Serial.print(gps.time.minute());
          Serial.print(F(":"));
          Serial.println(gps.time.second());
        }
          else {
          Serial.println(F("INVALID"));
          }

          Serial.print(F("- speed: "));
        if (gps.speed.isValid()) {
          float speed = gps.speed.kmph();
          
          if (speed > 0 && speed != lastSpeed) {
            lastSpeed = speed;
            if (speed > 50) {
              interval = 2000; // Intervalle de 2secondes pour les vitesses > 50 km/h
            } else if (speed > 30) {
              interval = 5000; // Intervalle de 5 secondes pour les vitesses > 30 km/h
            } else {
              interval = 10000; // Intervalle de 10 secondes pour les vitesses <= 30 km/h

            }
            // Afficher la vitesse et l'intervalle de prise de données
            Serial.print("Speed: ");
            Serial.print(speed);
            Serial.print(" km/h, Interval: ");
            Serial.print(interval / 1000);
            Serial.println(" seconds");
            
          }
        }
         else {
        Serial.println(F("INVALID"));
        }
        Serial.flush(); // Vider le buffer après un affichage, le faire à un autre moment ? 
  }

}
void ppsISR() {
// lastPpsTime = millis(); // Si je mets ici, à chaque PPS, on met à jour le lastPpsTime 
  ppsTriggered = true;
}
