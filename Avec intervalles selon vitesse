#include <SoftwareSerial.h>
#include <TinyGPS++.h>


const int RXPin = 4, TXPin = 3;  
const uint32_t GPSBaud = 4800;

TinyGPSPlus gps; 
SoftwareSerial gpsSerial(RXPin, TXPin);  // Attention, important de définir les constantes avant de créer les objets 

// !! On utilise les propriétés de la fonction millis() plutôt que celle de delay() car delay() arrête complètement l'exécution du programme pendant le temps spécifié.
// Or nous savons cela pose des problèmes. Il nous faut une temporisation non bloquante, on le fait avec l'aide de la fonction millis()

unsigned long previousMillis = 0; // Temps depuis le dernier enregistrement GPS
const long minInterval = 1000; // Intervalle de prise de données minimum (1 seconde)
long interval = 30000; // Intervalle de prise de données initial (30 secondes)
float lastSpeed = 0; // Dernière vitesse enregistrée

void setup() {    // put your setup code here, to run once:
  Serial.begin(9600); // Set the baud rate for the SoftwareSerial object. Sets the speed (baud rate) for the serial communication.
  gpsSerial.begin(GPSBaud); // mtn on met que notre ojet a lui un baudrate = 4800 = GPSBaud

  Serial.println(F("Arduino - GPS module")); // affichage de Arduino - GPS module dans le monitueur // println quand affichage + retour à la ligne
}

void loop() {
  unsigned long currentMillis = millis(); // Temps actuel

  // Vérifier si l'intervalle de prise de données est écoulé
  if (currentMillis - previousMillis >= interval) {
    previousMillis = currentMillis;

    // Lire les données GPS
    while (gpsSerial.available()) {
      if (gps.encode(gpsSerial.read())) {
        if (gps.location.isValid()) {   
        Serial.print(F("- latitude: "));
        Serial.println(gps.location.lat());

        Serial.print(F("- longitude: "));  //print(F()) signifie que le string n'utilise pas de RAM. Si vous utilisez F(), vous pouvez déplacer les string constant vers la mémoire programme au lieu de la RAM. Cela prendra de l'espace et diminuera la quantité d'autre code que vous pouvez écrire. Mais cela libérera de la RAM dynamique.
        Serial.println(gps.location.lng());

        Serial.print(F("- altitude: "));
        if (gps.altitude.isValid())
          Serial.println(gps.altitude.meters());
        else
          Serial.println(F("INVALID"));
      } else {
        Serial.println(F("- location: INVALID"));
      }

        Serial.print(F("- speed: "));
        if (gps.speed.isValid()) {
          float speed = gps.speed.kmph();
          if (speed > 0 && speed != lastSpeed) {
            lastSpeed = speed;
            if (speed > 50) {
              interval = 5000; // Intervalle de 5 secondes pour les vitesses > 50 km/h
            } else if (speed > 30) {
              interval = 10000; // Intervalle de 10 secondes pour les vitesses > 30 km/h
            } else {
              interval = 30000; // Intervalle de 30 secondes pour les vitesses <= 30 km/h
            }
            // Afficher la vitesse et l'intervalle de prise de données
            Serial.print("Speed: ");
            Serial.print(speed);
            Serial.print(" km/h, Interval: ");
            Serial.print(interval / 1000);
            Serial.println(" seconds");
            
          }
        }
         else {
        Serial.println(F("INVALID"));
        }
      }
    }
  }
  
  // Autres tâches à exécuter pendant la temporisation
  // ...
}

// Je pense que c'est ce if qui faisait tout buger -> problème entre le millis()> 5000 et le besoin d'utiliser le millis pour les intervalles 
/*  if (millis() > 5000 && gps.charsProcessed() < 10) // Si en cours depuis plus de 5 secondes et moins de 10 données reçus alors invalid 
    Serial.println(F("No GPS data received: check wiring"));
}
*/
